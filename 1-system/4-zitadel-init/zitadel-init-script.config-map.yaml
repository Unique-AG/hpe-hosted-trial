apiVersion: v1
kind: ConfigMap
metadata:
  name: zitadel-init-script
  annotations:
    argocd.argoproj.io/sync-wave: "4"
data:
  init-zitadel.py: |
    #!/usr/bin/env python3
    import os
    import sys
    import time
    import yaml
    import base64
    import json
    import jwt
    import requests
    from requests.exceptions import RequestException
    from kubernetes import client, config

    # Configuration
    ZITADEL_DOMAIN = os.environ.get('ZITADEL_DOMAIN', 'http://zitadel.unique.svc.cluster.local:8080')
    CONFIG_PATH = os.environ.get('CONFIG_PATH', '/config/config.yaml')
    PRIVATE_KEY_PATH = os.environ.get('PRIVATE_KEY_PATH', '/secrets/privateKey')
    USER_ID = os.environ.get('USER_ID', 'superuser')
    NAMESPACE = os.environ.get('NAMESPACE', 'unique')

    class ZitadelInitializer:
        def __init__(self):
            print(f"Zitadel domain: {ZITADEL_DOMAIN}")
            self.domain = ZITADEL_DOMAIN
            self.config = self._load_config()
            self.token = self._generate_jwt()
            print(f"Generated token : {self.token}")
            self.headers = {
                'Content-Type': 'application/json',
                'Authorization': f'Bearer {self.token}'
            }
            
        def _load_config(self):
            with open(CONFIG_PATH, 'r') as f:
                config = yaml.safe_load(f)
                
            # Replace environment variables in config
            config_str = yaml.dump(config)
            for key, value in os.environ.items():
                config_str = config_str.replace(f'${{{key}}}', value)
            
            return yaml.safe_load(config_str)
            
        def _generate_jwt(self):
            print(f"Reading private key from: {PRIVATE_KEY_PATH}")
            with open(PRIVATE_KEY_PATH, 'r') as f:
                private_key_base64 = f.read()
            
            print(f"Base64 encoded key length: {len(private_key_base64)} characters")
            
            # Decode the base64 encoded key
            try:
                private_key = base64.b64decode(private_key_base64).decode('utf-8')
                print(f"Decoded key length: {len(private_key)} characters")
                print(f"Decoded key starts with: {private_key[:50]}...")
            except Exception as e:
                print(f"Base64 decoding failed: {str(e)}")
                print("Falling back to using the raw key")
                private_key = private_key_base64
            
            # Check if private key is in PEM format
            if "-----BEGIN" not in private_key:
                print("Key doesn't appear to be in PEM format, trying to format it")
                private_key = f"-----BEGIN RSA PRIVATE KEY-----\n{private_key}\n-----END RSA PRIVATE KEY-----"
            
            now = int(time.time())
            payload = {
                'iss': USER_ID,
                'sub': USER_ID,
                'aud': self.domain,
                'exp': now + 3600,
                'iat': now
            }
            
            return jwt.encode(payload, private_key, algorithm='RS256')
        
        def _api_request(self, method, endpoint, data=None, org_id=None):
            url = f"{self.domain}{endpoint}"
            print(f"API request URL: {url}")
            headers = self.headers.copy()
            
            if org_id:
                headers['x-zitadel-orgid'] = org_id
                
            try:
                if method == 'GET':
                    response = requests.get(url, headers=headers)
                elif method == 'POST':
                    response = requests.post(url, headers=headers, json=data)
                elif method == 'DELETE':
                    response = requests.delete(url, headers=headers)
                elif method == 'PUT':
                    response = requests.put(url, headers=headers, json=data)
                else:
                    raise ValueError(f"Unsupported HTTP method: {method}")
                    
                response.raise_for_status()
                return response.json()
            except RequestException as e:
                print(f"API request failed: {e}")
                if hasattr(e, 'response') and e.response:
                    print(f"Response: {e.response.text}")
                raise
        
        def check_health(self):
            print("Checking Zitadel health status...")
            try:
                url = f"{self.domain}/admin/v1/healthz"
                response = requests.get(url, headers={
                    'Accept': 'application/json',
                    'Authorization': f'Bearer {self.token}'
                })
                response.raise_for_status()
                health_data = response.json()
                print(f"Zitadel health status: {health_data}")
                return True
            except Exception as e:
                print(f"Health check failed: {e}")
                if hasattr(e, 'response') and e.response:
                    print(f"Response: {e.response.text}")
                return False

        def test_api(self):
            print("Testing Zitadel API with system/v1/instances/_search...")
            try:
                url = f"{self.domain}/system/v1/instances/_search"
                print(f"Testing API URL: {url}")
                
                response = requests.post(
                    url,
                    headers={
                        'Content-Type': 'application/json',
                        'Authorization': f'Bearer {self.token}'
                    },
                    json={},
                    verify=False  # Note: verify=False should only be used in development
                )
                
                print(f"API test status code: {response.status_code}")
                
                if response.ok:
                    print(f"API test successful: {response.text}")
                    return True
                else:
                    print(f"API test failed with status {response.status_code}: {response.text}")
                    # Print response headers for debugging
                    print(f"Response headers: {dict(response.headers)}")
                    return False
            except Exception as e:
                print(f"API test exception: {e}")
                if hasattr(e, 'response') and e.response:
                    print(f"Response: {e.response.text}")
                return False
        
        def get_default_org(self):
            print("Getting default organization...")
            return self._api_request('GET', '/admin/v1/orgs/default')
        
        def create_project(self, org_id, project_name):
            print(f"Creating project: {project_name}")
            return self._api_request('POST', '/management/v1/projects', {
                'name': project_name,
                'projectRoleAssertion': True,
                'projectRoleCheck': True,
                'hasProjectCheck': True
            }, org_id)
        
        def create_application(self, org_id, project_id, app_config):
            print(f"Creating application: {app_config['name']}")
            app_data = {
                'name': app_config['name'],
                'redirectUris': app_config['redirectUris'],
                'responseTypes': ['OIDC_RESPONSE_TYPE_CODE'],
                'grantTypes': ['OIDC_GRANT_TYPE_AUTHORIZATION_CODE', 'OIDC_GRANT_TYPE_REFRESH_TOKEN'],
                'appType': 'OIDC_APP_TYPE_WEB',
                'authMethodType': 'OIDC_AUTH_METHOD_TYPE_NONE',
                'postLogoutRedirectUris': app_config['postLogoutRedirectUris'],
                'devMode': False,
                'accessTokenType': 'OIDC_TOKEN_TYPE_JWT',
                'accessTokenRoleAssertion': True,
                'idTokenRoleAssertion': True,
                'idTokenUserinfoAssertion': True,
                'clockSkew': '0s'
            }
            return self._api_request('POST', f'/management/v1/projects/{project_id}/apps/oidc', app_data, org_id)
        
        def create_roles(self, org_id, project_id, roles):
            results = []
            for role in roles:
                print(f"Creating role: {role}")
                result = self._api_request('POST', f'/management/v1/projects/{project_id}/roles', {
                    'roleKey': role,
                    'displayName': role,
                    'group': 'default'
                }, org_id)
                results.append(result)
            return results
        
        def create_organization(self, org_name, domain):
            print(f"Creating organization: {org_name}")
            return self._api_request('POST', '/admin/v1/orgs/_setup', {
                'org': {
                    'name': org_name,
                    'domain': domain
                },
                'roles': []
            })
        
        def create_project_grant(self, org_id, project_id, granted_org_id, roles):
            print(f"Creating project grant for org: {granted_org_id}")
            return self._api_request('POST', f'/management/v1/projects/{project_id}/grants', {
                'grantedOrgId': granted_org_id,
                'roleKeys': roles
            }, org_id)
        
        def create_user_grant(self, org_id, user_id, project_id, project_grant_id, roles):
            print(f"Creating user grant for user: {user_id}")
            return self._api_request('POST', f'/management/v1/users/{user_id}/grants', {
                'projectId': project_id,
                'projectGrantId': project_grant_id,
                'roleKeys': roles
            }, org_id)
        
        def create_service_user(self, org_id, username, description):
            print(f"Creating service user: {username}")
            return self._api_request('POST', '/management/v1/service-users', {
                'username': username,
                'description': description
            }, org_id)
        
        def create_personal_access_token(self, org_id, user_id, token_name, expiration_days=90):
            print(f"Creating personal access token for user: {user_id}")
            return self._api_request('POST', f'/management/v1/users/{user_id}/tokens', {
                'tokenName': token_name,
                'expirationDate': f"{expiration_days}d"
            }, org_id)
        
        def create_zitadel_action(self, org_id, name, script, trigger_type):
            print(f"Creating Zitadel action: {name}")
            return self._api_request('POST', '/management/v1/actions', {
                'name': name,
                'script': script
            }, org_id)
        
        def assign_action_to_flow(self, org_id, action_id, flow_type, trigger_type):
            print(f"Assigning action {action_id} to flow")
            return self._api_request('POST', '/management/v1/flows/actions', {
                'actionId': action_id,
                'flowType': flow_type,
                'triggerType': trigger_type
            }, org_id)
        
        def create_k8s_secret(self, name, data):
            try:
                # Load in-cluster config
                config.load_incluster_config()
                
                # Create API client
                v1 = client.CoreV1Api()
                
                # Encode secret data
                encoded_data = {}
                for key, value in data.items():
                    encoded_data[key] = base64.b64encode(value.encode()).decode()
                
                # Create Secret
                secret = client.V1Secret(
                    api_version="v1",
                    kind="Secret",
                    metadata=client.V1ObjectMeta(name=name),
                    data=encoded_data
                )
                
                # Create or update the Secret
                try:
                    v1.create_namespaced_secret(namespace=NAMESPACE, body=secret)
                    print(f"Created Secret '{name}'")
                except client.exceptions.ApiException as e:
                    if e.status == 409:  # Conflict, secret already exists
                        v1.patch_namespaced_secret(name=name, namespace=NAMESPACE, body=secret)
                        print(f"Updated Secret '{name}'")
                    else:
                        raise
            except Exception as e:
                print(f"Error creating Kubernetes Secret: {e}")
                return False
            
            return True
        
        def run(self):
            try:
                # Check if Zitadel is healthy
                if not self.check_health():
                    print("Zitadel is not healthy, aborting initialization")
                    return 1
                
                # Test the API
                self.test_api()
                
                # Get default organization
                default_org = self.get_default_org()
                root_org_id = default_org['org']['id']
                
                # Setup project
                project_name = self.config['project']['name']
                project_roles = self.config['project']['roles']
                
                # Create project
                project = self.create_project(root_org_id, project_name)
                project_id = project['id']
                
                # Create application
                app_config = self.config['application']
                application = self.create_application(root_org_id, project_id, app_config)
                client_id = application['clientId']
                
                # Create roles
                self.create_roles(root_org_id, project_id, project_roles)
                
                # Setup organization
                org_name = self.config['organization']['name']
                # TODO: change to the domain of the organization
                org_domain = f"{org_name.lower().replace(' ', '-')}.example"
                
                org_result = self.create_organization(org_name, org_domain)
                org_id = org_result['orgId']
                user_id = org_result['userId']
                
                # Create project grant
                grant_result = self.create_project_grant(root_org_id, project_id, org_id, project_roles)
                grant_id = grant_result['grantId']
                
                # Create user grant
                self.create_user_grant(org_id, user_id, project_id, grant_id, project_roles)
                
                # Create service user for scope management
                service_user = self.create_service_user(
                    org_id, 
                    "scope-management-service", 
                    "Service user for managing scopes"
                )
                service_user_id = service_user['userId']
                
                # Create personal access token for service user
                pat_result = self.create_personal_access_token(org_id, service_user_id, "scope-management-token")
                pat_token = pat_result['token']
                
                # Create Zitadel Actions
                add_grant_script = f"""
                function addGrant(ctx, api) {{
                  api.userGrants.push({{
                    projectID: '{project_id}',
                    projectGrantID: '{grant_id}',
                    roles: ['chat.chat.basic']
                  }});
                }}
                """
                
                add_grant_action = self.create_zitadel_action(org_id, "addGrant", add_grant_script, "POST_CREATION")
                self.assign_action_to_flow(org_id, add_grant_action['actionId'], "FLOW_TYPE_CREATION", "TRIGGER_TYPE_POST_CREATION")
                
                # Create Kubernetes Secret with credentials
                secret_created = self.create_k8s_secret("zitadel-credentials", {
                    'projectId': project_id,
                    'clientId': client_id,
                    'organizationId': org_id,
                    'serviceUserId': service_user_id,
                    'serviceUserToken': pat_token
                })
                
                # Output results
                print("\n=== Zitadel Setup Complete ===")
                print(f"Project ID: {project_id}")
                print(f"Client ID: {client_id}")
                print(f"Organization ID: {org_id}")
                print(f"Service User ID: {service_user_id}")
                
                # Save to a result file that can be mounted as a volume
                with open('/output/result.json', 'w') as f:
                    json.dump({
                        'projectId': project_id,
                        'clientId': client_id,
                        'organizationId': org_id,
                        'serviceUserId': service_user_id,
                        'serviceUserToken': pat_token
                    }, f)
                    
                print("Results saved to /output/result.json")
                if secret_created:
                    print("Kubernetes Secret 'zitadel-credentials' created with all credentials")
                return 0
                
            except Exception as e:
                print(f"Error initializing Zitadel: {e}")
                return 1

    if __name__ == "__main__":
        initializer = ZitadelInitializer()
        sys.exit(initializer.run())